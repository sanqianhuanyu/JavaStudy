多线程

##了解多线程

### 进程和线程的区别

>每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。
>
>使用线程可以把占据时间长的程序中的任务放到后台去处理，程序的运行速度可能加快，在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。
>
>如果有大量的线程,会影响性能，因为操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。
>
>总结:进程是所有线程的集合，每一个线程是进程中的一条执行路径。

### 为什么要使用多线程

>**总结多线程的好处提高程序的效率。**

### 多线程的创建方式

[多线程的创建方式](线程创建方式使用.md)

### 多线程的常用方法

| **常用线程****api****方法**      |                                                    |
| -------------------------------- | -------------------------------------------------- |
| start()                          | 启动线程                                           |
| currentThread()                  | 获取当前线程对象                                   |
| getID()                          | 获取当前线程ID   Thread-编号 该编号从0开始         |
| getName()                        | 获取当前线程名称                                   |
| sleep(long mill)                 | 休眠线程                                           |
| Stop（）                         | 停止线程                                           |
| **常用线程构造函数**             |                                                    |
| Thread（）                       | 分配一个新的 Thread 对象                           |
| Thread（String name）            | 分配一个新的 Thread对象，具有指定的 name正如其名。 |
| Thread（Runable r）              | 分配一个新的 Thread对象                            |
| Thread（Runable r, String name） | 分配一个新的 Thread对象                            |

### 线程的状态

![](https://note.youdao.com/yws/public/resource/68bba2bcc59acb94a07c2dcac2dd0c6c/xmlnote/9577358869A442A78007CDD2D1F66430/4621)

>1. 新建状态:
>   使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
>
>2. 就绪状态:
>   当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
>
>3. 运行状态:
>   如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
>
>4. 阻塞状态:
>
>   如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
>
>   - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
>   - 同步阻塞：线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)。
>   - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
>
>5. 死亡状态:
>   一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。
>
>

## 多线程安全

**为什么**

>当多个线程同时共享，同一个**全局变量或静态变量**，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。

**怎么解决线程安全**

>1.使用多线程之间同步或使用锁(lock)。
>
>2.将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题。
>
>3.当多个线程共享同一个资源,不会受到其他线程的干扰.

### 使用同步代码块

>什么是同步函数？
>
>在方法上修饰synchronized 称为同步函数

```
synchronized(同一个数据){
 可能会发生线程冲突问题
}
```

### 同步函数

>同步函数使用this锁。
>
>证明方式: 一个线程使用同步代码块(this明锁),另一个线程使用同步函数。如果两个线程抢票不能实现同步，那么会出现数据错误。

```java
public synchronized void sale() {
			if (trainCount > 0) { 
			try {
					Thread.sleep(40);
				} catch (Exception e) {
				}
System.out.println(Thread.currentThread().getName() + ",出售 第" + (100 - trainCount + 1) + "张票.");
				trainCount--;
			}
	}
```

### 静态同步函数

>方法上加上static关键字，使用synchronized 关键字修饰 或者使用类.class文件。
>
>静态的同步函数使用的锁是 该函数所属字节码文件对象 
>
>可以用 getClass方法获取，也可以用当前 类名.class 表示。

```java
synchronized (ThreadTrain.class) {
			System.out.println(Thread.currentThread().getName() + ",出售 第" + (100 - trainCount + 1) + "张票.");
			trainCount--;
			try {
				Thread.sleep(100);
			} catch (Exception e) {
			}
}
```

### 多线程死锁

>同步中嵌套同步,导致锁无法释放;
>
>两个或者多个线程相互等待对方释放锁;

## 多线程之间通信

> 多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。

### wait,notify,notifyAll

>wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。
>
>这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。
>
>·    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
>
>·    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
>
>·    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。
>
>











