### volatile

>作用是使变量在多个线程间可见。
>
>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。

**作用**

>1、**保证此变量对所有线程的"可见性"**，所谓"可见性"是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成，再强调一遍，**volatile只保证了可见性，并不保证基于volatile变量的运算在并发下是安全的**
>
>2、**使用volatile变量的第二个语义是禁止指令重排序优化**，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致

**定义规则**

>1、在工作内存中，每次使用某个变量的时候都必须线从主内存刷新最新的值，用于保证能看见其他线程对该变量所做的修改之后的值
>
>2、在工作内存中，每次修改完某个变量后都必须立刻同步回主内存中，用于保证其他线程能够看见自己对该变量所做的修改
>
>3、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同

####文章

[了解volatile](https://blog.csdn.net/weixin_34384557/article/details/93921761)

### synchronzied

>synchronized是JVM内建的同步机制，提供了**互斥性和可见性**来保证多线程安全。当某一线程获取到当前锁时，其他线程只能处于阻塞或者等待状态

**使用**

1.作用于静态代码块,静态方法:类加锁

2.方法或者代码块:对象加锁

#### 文章

[synchronized详解](https://www.jianshu.com/p/16cec9b50ad2)

[synchronized和ReentrantLock的区别](https://www.jianshu.com/p/c6a602be4994)

###AtomicInteger

注意:不是线程安全,多线程不能保证

> 高并发的情况下，`i++`无法保证原子性，往往会出现问题，所以引入`AtomicInteger`类。
>
> 只能保证当前线程只能保证++和赋值同步;类似事务

#### 文章

[AtomicInteger的使用](https://blog.csdn.net/mranyang/article/details/52281865)







### 

