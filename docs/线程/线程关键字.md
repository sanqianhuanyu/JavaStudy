### Semaphore

* 作用

```
//主要是防止资源,请求线程同时处理的数量
```

* 代码

```
public class Worker extends Thread {
    private int num;

    private Semaphore semaphore;

    public Worker(int num, Semaphore semaphore) {
        this.num = num;
        this.semaphore = semaphore;
    }
    //semaphore 是什么
    //主要是防止资源,请求线程同时处理的数量
    //这样来处理

    @Override
    public void run() {
        try {
            semaphore.acquire();
            System.out.println("工人" + this.num + "占用一个机器在生产");
            Thread.sleep(2000);
            System.out.println("工人" + this.num + "释放出机器");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }

    public static void main(String[] args) {
        int N = 8;
        Semaphore semaphore = new Semaphore(5);
        for (int i = 0; i < N; i++) {
            new Worker(i, semaphore).start();
        }
    }
```

### CountDownLatch

* 作用

```
需要等待其他线程执行完,才执行任务;
```

* 代码

```
public class Demo {

   //countDownLatch CyclicBarrier Semaphore

    public static void main(String[] args) {

        final CountDownLatch countDownLatch = new CountDownLatch(2);

        new Thread(){
            @Override
            public void run() {
                try {
                    System.out.println(Thread.currentThread().getName()+"开始执行");
                    Thread.sleep(3000);
                    System.out.println(Thread.currentThread().getName()+"执行完毕");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();

        new Thread(){
            @Override
            public void run() {
                try {
                    System.out.println(Thread.currentThread().getName()+"开始执行");
                    Thread.sleep(3000);
                    System.out.println(Thread.currentThread().getName()+"执行完毕");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }.start();

        try {
            System.out.println("等待2个子线程执行完毕...");
            countDownLatch.await();
            System.out.println("2个子线程已经执行完毕");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```

### CyclicBarrier

```
public class Demo extends Thread {
    private CyclicBarrier cyclicBarrier;
    public Demo(CyclicBarrier cyclicBarrier) {
        this.cyclicBarrier = cyclicBarrier;
    }
    public static void main(String[] args) {
        int N = 4;
        CyclicBarrier barrier = new CyclicBarrier(N);
        for (int i = 0; i < N; i++) {
            new Demo(barrier).start();
        }
    }
    @Override
    public void run() {
        System.out.println("线程" + Thread.currentThread().getName() + "正在写入数据");
        try {
            Thread.sleep(5000);
            System.out.println("线程" + Thread.currentThread().getName() + "写入数据完毕,等待其他线程写入完毕");
            //上边操作,都完成才能向下执行
            cyclicBarrier.await();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("所有线程写入完毕,等待操作");
    }
}
```