### 为什么要使用索引

```
索引就像书的目录一样可以非常快速的定位到书的页码。
如果向mysql发出一条sql语句请求，查询的字段没有创建索引的话，可能会导致全表扫描，这样的话查询效率非常低。

```

### 数据结构Hash、平衡二叉树、B树、B+树区别

**哈希**

>哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
>
>优点:查找可以直接根据key访问
>缺点: 不能进行范围查找
>index=Hash(key)

**二叉树**

[索引,二叉树、平衡二叉树、b-tree、b+tree详解](https://blog.csdn.net/qq_36098284/article/details/80178336)

![](https://img-blog.csdn.net/20160202203448944)

**平衡二叉树**

[测试地址](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)

>平衡二叉查找树，又称 AVL树。 它除了具备二叉查找树的基本特征之外，还具有一个非常重要的特点：它 的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值（平衡因子 ） 不超过1。 也就是说AVL树每个节点的平衡因子只可能是-1、0和1（左子树高度减去右子树高度）。
>
>优点衡二叉树算法基本与二叉树查询相同，效率比较高
>
>缺点插入操作需要旋转，支持范围查询

![](https://img-blog.csdn.net/20160202203554663)

**B+**

[测试地址](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

>B+树相比B树，新增叶子节点与非叶子节点关系，叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value。
>
> **1.通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点。**
>
>  **2. 而且所有叶子节点（即数据节点）之间是一种链式环结构。**
>
>  **3.因此可以对B+Tree进行两种查找运算：**
>
>   **3.1一种是对于主键的范围查找和分页查找**
>
>   3.2 另一种是从根节点开始，进行随机查找。

**所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高。**

![](https://img-blog.csdn.net/20160202205105560)

**B+和B树区别**

```
B+树 解决范围查询问题、减少IO查询的操作。


B+树相比B树，新增叶子节点与非叶子节点关系，叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value。

B+树算法： 通过继承了B树的特征，B+树相比B树，新增叶子节点与非叶子节点关系，叶子节点中包含了key和value，非叶子节点中只是包含了key，不包含value。通过非叶子节点查询叶子节点获取对应的value，所有相邻的叶子节点包含非叶子节点，使用链表进行结合，有一定顺序排序，从而范围查询效率非常高。
缺点：因为有冗余节点数据，会比较占内存。

```

### 机械硬盘和固态硬盘区别

```
固态硬盘 容量小,随机存放快
```

### myisam和Innodb B+区别

[区别](https://blog.csdn.net/u010842515/article/details/68929687)

```
MyISAM和InnoDB对B-Tree索引不同的实现方式然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同.
 MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
```

**myisam**

```
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM主键索引的原理图：

```

![img](http://images.cnitblog.com/blog2015/740638/201504/192216401045034.png)



**Innodb**

```
   MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
   
(图inndb主键索引）是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
```

![img](http://images.cnitblog.com/blog2015/740638/201504/192217506822639.png)

### mysql索引的数据结构

```
hash 二叉树, 平衡二叉树,B,B+

```

[区别](https://blog.csdn.net/pengzhisen123/article/details/79927377)

### B+树的节点到底存放多少节点

>局部性原理与磁盘预读
> 计算机科学中著名的局部性原理当一个数据被用到时， 其附近的数据也通常会马上被使用。
> 为了提高效率，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。
> 这里的-定长度叫做页，也就是操作系统操作磁盘时的基本单位。一般操作系统中.页的大小是4Kb (getconf  PAGE_SIZE)
> 总结
> 如果一个B树或B+树中的节点的大小
>
>假设一个节点为1页
>
>如果从磁盘读取超过1页大小，根据局部性原理与磁盘预读 会读出2页大小
> 如果从磁盘读取小于1页大小，根据局部性原理与磁盘预读 会读出1页大小
>
>
> 根据以上规则，如果读取整哈是页的倍数，这样就可以不用浪费，所以B+树的每一个节点是页的倍数是最佳的。
>
>在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：
>
>show variables like 'innodb_page_size';
>
>16384/1024=16kb;
>
>MySQLb+树能够存放多少字节数据
>
>假设一行为1kb，那么一页可以读取16行数据，一个叶子节点可以存放16条数据
>
>那么非叶子节点存放多少条数据？非叶子节点存放索引值(bigint 8b)和指针(6b)
>
>那么一页16*1024/(8+6)=1170指针
>
>B+树 高度为2  1170*16=18720 条数据
>
>B+树 高度为3  1170*1170*16=21902400 条数据
>
>所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。

### mysql慢查询配置

>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。              

```
参数说明:
slow_query_log 慢查询开启状态
slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）
long_query_time 查询超过多少秒才记录
1.查询慢查询配置
show variables like 'slow_query%';
2.查询慢查询限制时间
show variables like 'long_query_time';
3.将 slow_query_log 全局变量设置为“ON”状态
set global slow_query_log='ON'; 
4.查询超过1秒就记录
set global long_query_time=1;
5.查询cat /var/lib/mysql/localhost-slow.log
service mysqld restart
```

### 索引为什么会失效

> Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。

```
1.	索引无法存储null值
2.	前导模糊查询不能利用索引(like '%XX'或者like '%XX%')
3.	索引失效的几种情况
1.如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)
要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引
2.对于多列索引，不是使用的第一部分，则不会使用索引
3.like查询以%开头
4.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5.如果mysql估计使用全表扫描要比使用索引快,则不使用索引
```

**测试**

```
CREATE TABLE `user_details` (
  `id` int(11) DEFAULT NULL,
  `user_name` varchar(50) DEFAULT NULL,
  `user_phone` varchar(11) DEFAULT NULL,
  PRIMARY KEY (id,user_name)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 分库分表查询快

```
分表分库为什么提高查询的效率？因为会将一张表的数据拆分成多个n张表进行存放，让后在使用第三方中间件（MyCat或者Sharding-JDBC）并行同时查询，让后在交给第三方中间进行组合返回给客户端。
```

